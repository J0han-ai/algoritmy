# algoritmy
основные алгоритмы сортировки массива

Обзор алгоритмов сортировки массива:
пузырьковая сортировка,
сортировка выбором,
сортировка вставкой,
сортировка Шелла,
быстрая сортировка,
сортировка слиянием.
Жадный алгоритм.
Алгоритмы поиска пути:
обход в глубину,
обход в ширину.
Транспортный алгоритм — алгоритм Дейкстры.
Что же, без лишних предисловий приступим к делу.
1. Обзор алгоритмов сортировки
Пузырьковая сортировка
Данный алгоритм сортировки известен в первую очередь за счёт своей простоты, однако при этом он имеет одну из наиболее низких скоростей выполнения.

В качестве примера рассмотрим пузырьковую сортировку для чисел в возрастающем порядке.

Представим себе цепочку случайно расставленных чисел, для которых будут выполняться следующие шаги, начиная с начала цепочки:
сравнить два числа;
если число слева больше, то поменять их местами;
перейти на одну позицию вправо.
После прохождения по всей цепочке с выполнением данных шагов мы обнаружим, что наибольшее число оказалось в конце нашего ряда чисел.

Далее выполняется точно такой же проход по цепочке с выполнением вышеописанных шагов. Но в этот раз мы не будем включать последний элемент списка, так как он самый большой и уже стоит на последнем месте, как и должен.

Опять, же мы получим последний элемент в конце нашего ряда рассматриваемых чисел. 

Соответственно, уже два наибольших числа будут стоять на своих местах.
И опять запускается проход по цепочке за исключением элементов, которые уже на своих местах, до тех пор, пока все элементы не будут стоять в необходимом порядке.

Давайте рассмотрим реализацию пузырьковой сортировки в Java-коде:

public class Solution {
   public static void main(String[] args) {
    int[] testArr = new int[]{6,3,8,2,6,9,4,11,1};
    bubbleSort(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static void  bubbleSort(int[] array) {
       for(int i = array.length -1; i > 1; i--) {
         for (int j = 0; j < i; j++) { 
//

             if (array[j] > array[j+1]) {
                 int temp = array[j];
                 array[j] = array[j+1];
                 array[j+1] = temp;
             }
         }
       }
   }
}

Как видите, ничего сложного тут нет, и всё вроде бы как здорово, если бы не одно “но”…

Пузырьковая сортировка весьма и весьма медленная, с временной сложностью O(N²), так как мы имеем вложенные циклы. Внешний проход по элементам выполняется за N раз, внутренний — тоже N раз, и в итоге мы получаем N*N, N² итераций

Более подробно изучить данный вид сортировки можно в этой статье.
Сортировка методом выбора
Данный алгоритм имеет схожесть с пузырьковой сортировкой, но работает он несколько быстрее. Опять в качестве примера возьмём ряд чисел, которые мы хотим расставить в возрастающем порядке.

Суть алгоритма заключается в последовательном переборе всех чисел и выборе наименьшего элемента, который мы возьмём и поменяем местами с крайним элементом слева (0 элементом).

Тут у нас получается ситуация, схожая с пузырьковой сортировкой, но в данном случае отсортированным элементом у нас будет наименьший.

Поэтому, следующий проход по элементам будет начинаться с элемента под индексом 1. Опять же, данные проходы будет повторяться до тех пор, пока все элементы не будут отсортированы.

Реализация в Java:

public class Solution {
   public static void main(String[] args) {
       int[] testArr = new int[]{6, 3, 8, 2, 6, 9, 4, 11, 1};
       sortBySelect(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static void sortBySelect(int[] array) {

       for (int i = 0; i < array.length-1; i++) { 
// внешний обычный  цикл

           int min = i;

           for (int j = i + 1; j < array.length; j++) { 
// обычный цикл, но с отчетом с сортированных чисел

               if (array[j] < array[min]) {
                   min = j;
               }
           }
           int temp = array[i];     
// вставка отссортиованного числа, в положеную ему ячейку

           array[i] = array[min];
           array[min] = temp;
       }
   }
}

Данный алгоритм превосходит пузырьковую сортировку, ведь тут количество необходимых перестановок сокращается с O(N²) до O(N): мы не гоняем один элемент через весь список, но тем не менее, количество сравнений остается O(N²).

Желающим ознакомиться подробнее с этим алгоритмом рекомендую этот материал.
Сортировка методом вставки
В очередной раз для примера возьмём ряд чисел, которые мы хотим расставить в возрастающем порядке.

Данный алгоритм заключается в выставлении маркера, слева от которого элементы будут уже частично отсортированы между собой. На каждом шаге алгоритма будет выбираться один из элементов и помещаться на нужную позицию в уже отсортированной последовательности. Таким образом, отсортированная часть будет увеличиваться до тех пор, пока не будут просмотрены все элементы. 

Вы спросите: а где же взять ту часть элементов, которые уже отсортированы и после которых и нужно ставить маркер? 

Но ведь массив из первого элемента уже отсортирован, не так ли?


Давайте посмотрим на реализацию в Java:

public class Solution {
   public static void main(String[] args) {
       int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
       insertionSort(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static void insertionSort(int[] array) {

       for (int i = 1; i < array.length; i++) { 
// i - разделяющий маркер

           int temp = array[i]; 
// делаем копию помеченного элемента

           int j = i;
           while (j 	> 0 && array[j - 1] >= temp) { 
// пока не будет найден меньший элемент

               array[j] = array[j - 1]; 
// сдвигаем элементы вправо

               --j;
           }
           array[j] = temp;   
// вставляем отмеченный элемент, в положеное ему место

       }
   }
}

Данный вид сортировки превосходит вышеописанные, так как несмотря на то, что время работы такое же — O(N²), этот алгоритм работает вдвое быстрее пузырьковой сортировки и немного быстрее сортировки выбором.

Подробнее — вот тут.
Сортировка Шелла
Данная сортировка, по своей природе является модифицированной сортировкой методом вставки. О чём я говорю? Давайте по порядку.

Выбирается шаг, причем к у этого выбора есть много подходов. Слишком подробно разбираться в этом вопросе не будем. Поделим наш массив пополам и получим некоторое число — это и будет нашим шагом. 

Итак, если у нас в массиве 9 элементов, то наш шаг будет 9/2 = 4,5.

Дробную часть мы отбросим и получим 4, так как индексы массивов — только целые числа.

С помощью данного шага мы составим связи для наших групп. Если элемент имеет индекс 0, то индекс следующего элемента в его группе — 0+4, то есть 4. Третий элемент будет иметь индекс 4+4, четвертый — 8+4, и так далее.

У второй группы первый элемент будет 1,5,9….

В третьей и четвертой группе дела будут обстоять точно так же.

В итоге из массива чисел {6,3,8,8,6,9,4,11,1} мы получим четыре группы:
I — {6,6,1} 
II — {3,9} 
III — {8,4} 
IV — {8,11}

Свои места в общем массиве они сохраняют, но для нас они помечены как участники одной группы:
{6,3,8,8,6,9,4,11,1}

Далее внутри этих групп происходит описанная выше сортировка вставками, после которой группы будут иметь вид:
I — {1,6,6} 
II — {3,9} 
III — {4,8} 
IV — {8,11}

В общем массиве ячейки, занимаемые группами, останутся теми же, но внутри них изменится порядок, согласно порядку групп выше:
{1,3,4,8,6,9,8,11,6}

Массив стал немного более упорядоченным, не так ли?

Следующий шаг, будет поделен на 2:
4/2 = 2

Имеем две группы:
I — {1,4,6,8,6} 
II — {3,8,9,11} 

B общий массив:
{1,3,4,8,6,9,8,11,6}

Проходим по обеим группам алгоритмом сортировки вставкой, и получаем массив:
{1,3,4,8,6,9,6,11,8}

Сейчас наш массив почти отсортирован. Осталась последняя итерация алгоритма: делим шаг на 2: 2/2 = 1.

Мы получаем группу, весь массив:
{1,3,4,8,6,9,6,11,8}

По которому проходим алгоритмом сортировки вставкой и получаем:
{1,3,4,6,6,8,8,9,11}

Давайте посмотрим, как мы может отобразить данную сортировку в Java-коде:

public class Solution {
   public static void main(String[] args) {
       int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
       sortBySelect(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static void sortBySelect(int[] array) {
       int length = array.length;
       int step = length / 2;
       while (step > 0) {
           for (int numberOfGroup = 1; numberOfGroup < length - step; numberOfGroup++) {
// проходим по всем нашим группам

              int j = numberOfGroup;
               while (j >= 0 && array[j] > array[j + step]) {
//сортировка вставкой внутри группы

                   int temp = array[j];
                   array[j] = array[j + step];
                   array[j + step] = temp;
                   j--;
               }
           }
           step = step / 2; 
// уменьшаем наш шаг

       }
   }
}

На данный момент толком не обоснована эффективность сортировки Шелла, так как в разных ситуациях результаты отличаются. Оценки, полученные на основании экспериментов, лежат в интервале от O(N3/2) до O(N7/6).
Быстрая сортировка
Это один из самых популярных алгоритмов, и поэтому на него стоит обратить особое внимание.

Суть данного алгоритма заключается в том, что в списке с элементами выбирается опорный элемент — по сути любой элемент, относительно которого нужно отсортировать остальные значения. Значения меньше его — слева, значения больше — справа.

Далее у правой и левой части также выбирается по опорному элементу и происходит то же самое: сортируются значения относительно этих элементов, потом у образовавшихся частей выбираются  опорные элементы — и так до тех пор, пока мы не получим отсортированный ряд.

Данный алгоритм в Java реализуется с помощью рекурсии:

public class Solution {
   public static void main(String[] args) {
       int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
       fastSort(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static void fastSort(int[] array) {
       recursionFastSort(array, 0, array.length - 1);
   }


   public static void recursionFastSort(int[] array, int min, int max) {
       if (array.length == 0)
// условие выхода из рекурсии,  если длина массива равна 0

           return;

       if (min >= max) 
//выходим, так как нечего уже делить

           return;


       int middle = min + (max - min) / 2;  
// выбираем середину

       int middleElement = array[middle];


       int i = min, j = max;
       while (i <= j) {  
// относительно элемента middle определяемменьшие элементы слева, большие справа

           while (array[i] < middleElement) {
               i++;
           }
           while (array[j] > middleElement) {
               j--;
           }

           if (i <= j) {      
//меняем местами

               int temp = array[i];
               array[i] = array[j];
               array[j] = temp;
               i++;
               j--;
           }
       }

       if (min < j) 
// запускаем рекурсию с элементами меньшими чем middle

           recursionFastSort(array, min, j);

       if (max > i)
// запускаем рекурсию с элементами большими чем middle

           recursionFastSort(array, i, max);
   }
}

Вне всяких сомнений, алгоритм быстрой сортировки считается самым популярным, так как в большинстве ситуаций он выполняется быстрее остальных, за время O(N*logN).
Сортировка слиянием
Эта сортировка тоже популярна. Она относится к одному из видов алгоритмов, работающих по принципу «разделяй и властвуй»: в них мы в первую очередь делим задачи на минимальные части (также представителем таких алгоритмов является быстрая сортировка).
 
Итак, в чём же суть данного алгоритма?

Разделяй:
Массив разбивается на две части примерно одинакового размера, каждая из этих двух частей делится еще на две, и так далее, пока не останутся наименьшие неделимые части.
 
Наименьшие неделимые части — это когда в каждом массиве есть по одному элементу, а значит, такой массив автоматически считается отсортированным.
Властвуй:
Тут и начинается процесс, задавший название алгоритму — слияние. Для этого берутся два получившиеся упорядоченных массива и сливаются в один. При этом наименьший из первых элементов двух массивов записывается в результирующий массив, и эта операция повторяется, пока не закончатся элементы в этих двух массивах.
 
То есть, если у нас есть два минимальных массива {6} и {4}, их значения будут сравнены и записан результат: {4,6}. 
 
Если будут отсортированные массивы {4,6} и {2,8}, то сперва сравнится значение 4 и 2, из которых 2 будет записано в результирующий массив. После этого будет сравниваться 4 и 8, 4 будет записано, и в конце сравнится 6 и 8. Соответственно, 6 будет записано, и только после него — 8. В итоге мы получим результирующий массив: {2,4,6,8}.
 
Каким же образом это будет выглядеть в Java-коде?

Для обработки данного алгоритма нам будет удобно воспользоваться рекурсией:

public class Solution {
   public static void main(String[] args) {
       int[] testArr = new int[]{6, 3, 8, 8, 6, 9, 4, 11, 1};
       mergeSort(testArr);
       for (int i : testArr) {
           System.out.println(i);
       }
   }

   public static int[] mergeSort(int[] array1) {
       int[] sortArr = Arrays.copyOf(array1, array1.length);
// массив для сортировки

       int[] bufferArr = new int[array1.length];
// буферный массив

       return recurtionMergeSort(sortArr, bufferArr, 0, array1.length);
   }


   public static int[] recurtionMergeSort(int[] sortArr, int[] bufferArr,
                                          int startIndex, int endIndex) {
       if (startIndex >= endIndex - 1) {
// выход из массива, когда в рассматриваемом промежутке массива, только один элемент

           return sortArr;
       }

       
// запускаем рекурсию, чтобы получить два отсортированных массива:

       int middle = startIndex + (endIndex - startIndex) / 2;
       int[] firstSortArr = recurtionMergeSort(sortArr, bufferArr, startIndex, middle);
       int[] secondSortArr = recurtionMergeSort(sortArr, bufferArr, middle, endIndex);

       
// Слияние отсортированных массивов:

       int firstIndex = startIndex;
       int secondIndex = middle;
       int destIndex = startIndex;
       int[] result = firstSortArr == sortArr ? bufferArr : sortArr;
       while (firstIndex < middle && secondIndex < endIndex) {
           result[destIndex++] = firstSortArr[firstIndex] < secondSortArr[secondIndex]
                   ? firstSortArr[firstIndex++] : secondSortArr[secondIndex++];
       }
       while (firstIndex < middle) {
           result[destIndex++] = firstSortArr[firstIndex++];
       }
       while (secondIndex < endIndex) {
           result[destIndex++] = secondSortArr[secondIndex++];
       }
       return result;
   }
}

Как и в быстрой сортировке, мы выносим рекурсивный метод в промежуточный, чтобы пользователю не нужно было заморачиваться над заданием дополнительных дефолтных аргументов, а можно было всего лишь задать массив, который необходимо отсортировать.

Так как данный алгоритм имеет схожесть с быстрей сотрировкой, то и скорость его выполнения та же — O(N*logN).
2. Greedy Algorithms
Жадный алгоритм — это подход, при котором на каждом этапе принимаются локально оптимальные решения и допускается, что конечное решение также окажется оптимальным. “Оптимальное” решение — то, которое предлагает наиболее очевидную и немедленную выгоду на определенном шаге/этапе.  

Чтобы рассмотреть данный алгоритм, выберем довольно распространенную задачу — о рюкзаке.

Давайте на секунду представим, что вы вор. Вы вломились ночью в магазин с рюкзаком, и перед вами некоторое множество товаров, которые вы можете украсть. Но при этом вместимость рюкзака ограничена — не более 30 условных единиц. В тоже время вы хотите унести набор товаров максимальной стоимости, которые только влезут в рюкзак. 

Как вы определите, что положить?

Итак, жадный алгоритм для задачи о рюкзаке состоит в следующих шагах (считаем, что все предметы помещаются в рюкзак):
Выбрать максимально дорогой предмет из еще не затронутых.
Если он помещается в рюкзак, положить его туда, если нет — пропускаем.
Все предметы перебрали? Если нет — возвращаемся к 1 пункту, если да — бежим из магазина, так как наша цель тут выполнена.
Давайте это рассмотрим, но уже в Java.

Так будет выглядеть класс предмета Item:

public class Item implements Comparable<Item> {
   private String name;
   private int weight;
   private int cost;

   public Item(String name, int weight, int cost) {
       this.name = name;
       this.weight = weight;
       this.cost = cost;
   }

   public String getName() {
       return name;
   }

   public int getWeight() {
       return weight;
   }

   public int getCost() {
       return cost;
   }

   @Override
   public int compareTo(Item o) {
       return this.cost > o.cost ? -1 : 1;
   }
}

Тут ничего особого: три поля — name, weight, cost — для задания характеристик предмета.

Также, как вы можете видеть, тут реализован интерфейс Comparable таким образом, чтобы мы могли сортировать наши Item по цене.

Дальше смотрим на класс нашего рюкзака — Bag:

public class Bag {
   private final int maxWeight;
   private List<Item> items;
   private int currentWeight;
   private int currentCost;

   public Bag(int maxWeight) {
       this.maxWeight = maxWeight;
       items = new ArrayList<>();
       currentCost = 0;
   }

   public int getMaxWeight() {
       return maxWeight;
   }

   public int getCurrentCost() {
       return currentCost;
   }

   public int getCurrentWeight() {
       return currentWeight;
   }

   public void addItem(Item item) {
       items.add(item);
       currentWeight += item.getWeight();
       currentCost += item.getCost();
   }
}

maxWeight — вместимость нашего рюкзака, которая задаётся при создании объекта;
items — объекты находящиеся в рюкзаке;
currentWeight, currentCost — текущий вес и стоимость всех вещей в рюкзаке, которые мы увеличиваем при добавлении нового предмета в методе addItem.
Собственно перейдем в класс, где и происходит всё действие:

public class Solution {

   public static void main(String[] args) {
       List<Item> items = new ArrayList<>();
       items.add(new Item("гитара",7, 800));
       items.add(new Item("утюг",6, 500));
       items.add(new Item("чайник",3, 300));
       items.add(new Item("лампа",4, 500));
       items.add(new Item("телевизор",15, 2000));
       items.add(new Item("ваза",2, 450));
       items.add(new Item("миксер",1, 400));
       items.add(new Item("блендер",3, 200));

       Collections.sort(items);

       Bag firstBag = new Bag(30);

       fillBackpack(firstBag, items);

       System.out.println("Вес рюкзака состовляет - " + firstBag.getCurrentWeight() +
               ", общая стоимость вещей в рюкзаке - " + firstBag.getCurrentCost());
}
}

Для начала мы создаем список элементов, сортируем его. Создаем объект сумки с вместимость 30 единиц. 

Далее отправляем элементы и объект сумки в метод fillBackpack, в котором, собственно, и заполняется рюкзак по жадному алгоритму:

public static void fillBackpack(Bag bag, List<Item> items) {
   for (Item item : items) {
       if(bag.getMaxWeight() > bag.getCurrentWeight() + item.getWeight()) {
            bag.addItem(item);
       }
   }
}

Всё предельно просто: мы начинаем проходить по отсортированному по стоимости списку элементов и складывать их в сумку, если позволяет вместимость. Если же не позволяет, элемент будет пропущен и продолжится проход по остальным элементам до конца списка.

Запустив main, мы получим вывод в консоль:

Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 3700

Собственно, это и есть пример жадного алгоритма: на каждом шагу выбирается локально-оптимальное решение, а в итоге вы получаете глобально-оптимальное решение. 

В нашем случае оптимальный вариант — это наиболее дорогой предмет.

Но является ли это лучшим решением? Вам не кажется, что можно немного модернизировать наше решение, чтобы можно было укомплектовать рюкзак с более высокой суммарной стоимостью?

Давайте взглянем, как это можно сделать:

public static void effectiveFillBackpack(Bag bag, List<Item> items) {
   Map<Double, Item> sortByRatio = new TreeMap(Collections.reverseOrder());
   for (Item item : items) {
       sortByRatio.put((double)item.getCost() / item.getWeight(), item);
   }

   for (Map.Entry entry : sortByRatio.entrySet()) {
       if(bag.getMaxWeight() > bag.getCurrentWeight() + entry.getValue().getWeight()) {
           bag.addItem(entry.getValue());
       }
   }
}

Тут мы в первую очередь вычисляем соотношение веса и цены для каждого предмета. Так сказать, сколько стоит одна единица данного предмета. И уже по этим значениям мы сортируем наши предметы и добавляем в нашу сумку.

Запустим:

Bag secondBag = new Bag(30);

effectiveFillBackpack(secondBag, items);

System.out.println("Вес рюкзака составляет - " + secondBag.getCurrentWeight() +
       ", общая стоимость вещей в рюкзаке - " + secondBag.getCurrentCost());

Получаем вывод в консоль:

Вес рюкзака составляет - 29, общая стоимость вещей в рюкзаке - 4150

Немного лучше, не правда ли?

Жадный алгоритм  на каждом шагу делает локально оптимальный выбор в расчете на то, что итоговое решение также будет оптимальным. Это не всегда оправдано, но для многих задач жадные алгоритмы действительно дают оптимум.

Временная сложность данного алгоритма — O(N), довольно неплохо, не так ли? 





++++++++++++

вторая часть - графы 


+++++++++++++++++


Ранее мы рассматривали различные алгоритмы сортировки массивов и так называемый жадный алгоритм.

Сегодня же мы поговорим о графах и алгоритмах, связанных с ними.

Граф — одна из самых гибких и универсальных структур в программировании. 

Граф G обычно задается при помощи пары множеств G = (V, R), где:
V — множество вершин;
R — множество линий, соединяющих пары вершин.
Обычные соединяющие линии называют ребрами:
Линии со стрелками — дугами:
Как правило граф представляют с помощью схемы, на которой некоторые вершины соединены ребрами (дугами).

Графы, связанные между собой дугами, непосредственно указывающими направление, называют Также ребрам (дугам) могут присваиваться веса — числа, представляющие физическое расстояние между двумя вершинами (или относительное время перехода между двумя вершинами). Такие графы и называют взвешенными:
направленными. Если же графы соединены ребрами, то есть без указания направления возможного движения, они становятся ненаправленными. Это значит, что перемещения по ним возможны в обоих направлениях: как от вершины А к В, так и от В к А.

Связный граф — граф, в котором от каждой вершины к любой другой вершине ведёт хотя бы один путь (как на примере выше).
3. Алгоритмы поиска пути (глубина, ширина)
Одна из основных операций, которые выполняются с графами, — это определение  всех вершин, достижимых от заданной вершины. Представьте, что вы пытаетесь определить, как можно добраться от одного города в другой с возможными пересадками. К одним городам можно добраться напрямую, к другим нужно ехать в обход через другие города. Существует много других ситуаций, в которых может понадобиться нахождение всех вершин, к которым можно найти путь от заданной вершины.

Так вот, существует два основных способа обхода графов: обход в глубину и обход в ширину, которые мы и рассмотрим. Оба способа обеспечат перебор всех связных вершин.

Для дальнейшего рассмотрения алгоритмов в глубину и ширину возьмем следующий граф:
Обход в глубину
Это один из наиболее распространенных методов обхода графа. Данная стратегия поиска в глубину состоит в том, чтобы идти «вглубь» графа насколько это возможно, а достигнув тупика, возвращаться к ближайшей вершине, у которой есть смежные ранее не посещенные вершины.

Этот алгоритм хранит в стеке информацию о том, куда следует вернуться при достижении “тупика”.

Правила обхода в глубину:
Посетить смежную, ранее не посещенную вершину, пометить её и занести в стек.
Перейти на данную вершину.
Повторить этап 1.
Если выполнение пункта 1 невозможно, вернуться к предыдущей вершины и попытаться повторить правило 1. Если это невозможно — вернуться к вершине до нее, и так далее, пока не найдем вершину, с которой можно продолжить обход.
Продолжать до тех пор, пока все вершины не окажутся в стеке.
https://cdn.javarush.ru/images/article/055f7f7c-ccf8-49ac-aa68-7500b3429c8d/512.webp
Давайте взглянем, как может выглядеть код для данного алгоритма в Java:

public class Graph {
  private final int MAX_VERTS = 10;
  private Vertex vertexArray[]; 
//массив вершин

  private int adjMat[][]; 
// матрица смежности

  private int nVerts; 
// текущее количество вершин

  private Stack stack;

  public Graph() { 
// инициализация внутрених полей

     vertexArray = new Vertex[MAX_VERTS];
     adjMat = new int[MAX_VERTS][MAX_VERTS];
     nVerts = 0;
     for (int j = 0; j < MAX_VERTS; j++) {
        for (int k = 0; k < MAX_VERTS; k++) {
           adjMat[j][k] = 0;
        }
     }
     stack = new Stack<>();
  }

  public void addVertex(char lab) {
     vertexArray[nVerts++] = new Vertex(lab);
  }

  public void addEdge(int start, int end) {
     adjMat[start][end] = 1;
     adjMat[end][start] = 1;
  }

  public void displayVertex(int v) {
     System.out.println(vertexArray[v].getLabel());
  }

  public void dfs() { 
// обход в глубину

     vertexArray[0].setWasVisited(true); 
// берётся первая вершина

     displayVertex(0);
     stack.push(0);

     while (!stack.empty()) {
        int v = getAdjUnvisitedVertex(stack.peek()); 
// вынуть индекс смежной веришины, еckи есть 1, нету -1

        if (v == -1) { 
// если непройденных смежных вершин нету

           stack.pop(); 
// элемент извлекается из стека

        }
        else {
           vertexArray[v].setWasVisited(true);
           displayVertex(v);
           stack.push(v); 
// элемент попадает на вершину стека

        }
     }

     for (int j = 0; j < nVerts; j++) {  
// сброс флагов

        vertexArray[j].wasVisited = false;
     }

  }

  private int getAdjUnvisitedVertex(int v) {
     for (int j = 0; j < nVerts; j++) {
        if (adjMat[v][j] == 1 && vertexArray[j].wasVisited == false) {
           return j; 
//возвращает первую найденную вершину

        }
     }
     return -1;
  }
}

Вершина имеет вид:

public class Vertex {
  private char label;  
// метка А например

  public boolean wasVisited;

  public Vertex(final char label) {
     this.label = label;
     wasVisited = false;
  }

  public char getLabel() {
     return this.label;
  }

  public boolean isWasVisited() {
     return this.wasVisited;
  }

  public void setWasVisited(final boolean wasVisited) {
     this.wasVisited = wasVisited;
  }
}

Запустим данный алгоритм с конкретными вершинами и посмотрим на корректность работы:

public class Solution {
  public static void main(String[] args) {
     Graph graph = new Graph();
     graph.addVertex('A'); 
//0

     graph.addVertex('B'); 
//1

     graph.addVertex('C'); 
//2

     graph.addVertex('D'); 
//3

     graph.addVertex('E'); 
//4

     graph.addVertex('F'); 
//5

     graph.addVertex('G'); 
//6


     graph.addEdge(0,1);
     graph.addEdge(0,2);
     graph.addEdge(0,3);
     graph.addEdge(1,4);
     graph.addEdge(3,5);
     graph.addEdge(5,6);

     System.out.println("Visits: ");
     graph.dfs();
  }
}


Вывод в консоли:
Visits:
A
B
E
C
D
F
G

Так как у нас есть матрица смежности и в методе прохода мы используем цикл, вложенный в цикл, то временная сложность будет O(N²).
Обход в ширину
Данный алгоритм, как и обход в глубину, является одним наиболее простых и базовых методов обхода графа. Его суть в том, что у нас есть некоторая текущая вершина, с которой мы все смежные, непройденные вершины, заносим в очередь и выбираем следующий элемент (который хранится первым в очереди), чтобы его сделать текущим…

Если это не так, граф становится несвязным:
Также ребрам (дугам) могут присваиваться веса — числа, представляющие физическое расстояние между двумя вершинами (или относительное время перехода между двумя вершинами). Такие графы и называют взвешенными:
Если разбить данный алгоритм на этапы, можно выделить следующие правила:
Посетить следующую, ранее не посещенную вершину, смежную с текущей вершиной, пометить её заранее и занести в очередь.
Если выполнение правила #1 невозможно — извлечь вершину из очереди и сделать её текущей вершиной.
Если правило #1 и #2 невозможно, обход закончен, а все вершины пройдены (если граф у нас связный).
Класс графа практически идентичен аналогичному классу из алгоритма поиска в глубину, за исключением метода, обрабатывающего алгоритм и замены внутреннего стека на очередь:

public class Graph {
  private final int MAX_VERTS = 10;
  private Vertex vertexList[]; 
//массив вершин

  private int adjMat[][]; 
// матрица смежности

  private int nVerts; 
// текущее количество вершин

  private Queue queue;

  public Graph() {
     vertexList = new Vertex[MAX_VERTS];
     adjMat = new int[MAX_VERTS][MAX_VERTS];
     nVerts = 0;
     for (int j = 0; j < MAX_VERTS; j++) {
        for (int k = 0; k < MAX_VERTS; k++) {  
// заполнение матрицы смежности нулями

           adjMat[j][k] = 0;
        }
     }
     queue = new PriorityQueue<>();
  }

  public void addVertex(char lab) {
     vertexList[nVerts++] = new Vertex(lab);
  }

  public void addEdge(int start, int end) {
     adjMat[start][end] = 1;
     adjMat[end][start] = 1;
  }

  public void displayVertex(int v) {
     System.out.println(vertexList[v].getLabel());
  }

  public void bfc() { 
// обход в глубину

     vertexList[0].setWasVisited(true);
     displayVertex(0);
     queue.add(0);
     int v2;

     while (!queue.isEmpty()) {
        int v = queue.remove();

        while((v2 = getAdjUnvisitedVertex(v))!=-1) {
// цикл будет работать, пока все смежные вершины не будут найденны, и не будут добавлены в очередь

           vertexList[v2].wasVisited =true;
           displayVertex(v2);
           queue.add(v2);
        }
     }

     for (int j = 0; j < nVerts; j++) {  
// сброс флагов

        vertexList[j].wasVisited = false;
     }

  }

  private int getAdjUnvisitedVertex(int v) {
     for (int j = 0; j < nVerts; j++) {
        if (adjMat[v][j] == 1 && vertexList[j].wasVisited == false) {
           return j; 
//возвращает первую найденную вершину

        }
     }
     return -1;
  }
}

Класс Vertex идентичен классу из алгоритма про поиск в глубину.

Давайте приведем данный алгоритм в действие:

public class Solution {
  public static void main(String[] args) {
     Graph graph = new Graph();
     graph.addVertex('A'); 
//0

     graph.addVertex('B'); 
//1

     graph.addVertex('C'); 
//2

     graph.addVertex('D'); 
//3

     graph.addVertex('E'); 
//4

     graph.addVertex('F'); 
//5

     graph.addVertex('G'); 
//6


     graph.addEdge(0,1);
     graph.addEdge(0,2);
     graph.addEdge(0,3);
     graph.addEdge(1,4);
     graph.addEdge(3,5);
     graph.addEdge(5,6);

     System.out.println("Visits: ");
     graph.bfc();
  }
}

Вывод в консоль:

Visits:
A
B
C
D
E
F
G

Опять же: мы имеем матрицу смежности и используем цикл, вложенный в цикл, поэтому O(N²) — временная сложность приведенного алгоритма.
4. Алгоритм Дейкстры
Как говорилось ранее, графы могут быть направленными и ненаправленными. И как вы помните, они ещё могут быть взвешенными.

Взвешенные, направленные графы часто встречаются и в реальной жизни: например, карта городов, где города — вершины, пути между ними — дороги, дороги могут иметь одностороннее движение — направление графа.

Допустим, вы занимаетесь грузоперевозками и нужно составить кратчайший путь между двумя отдаленными городами. Каким образом вы это сделаете? 

Одной из самых распространённых задач, связанной со взвешенными графами, является задача выбора кратчайшего пути между двумя вершинами.

Для решения данной задачи мы и используем алгоритм Дейкстры.

Хотелось бы сразу отметить, что выполнив алгоритм Дейкстры мы узнаем кратчайшие пути ко всем вершинам от заданной начальной. 

Какие же этапы имеет данный алгоритм? Попытаюсь ответить на данный вопрос.

Этапы алгоритма Дейкстры:
Этап 1: поиск узла, переход к которому будет составлять наименьшую стоимость. Вы стоите в самом начале и думаете, куда направиться: к узлу А или к узлу В. Сколько времени понадобится, чтобы добраться до каждого из этих узлов?
Этап 2: вычисление, сколько времени нужно, чтобы добраться до всех ещё не затронутых алгоритмом соседей В при переходе по ребру из В. Если же это новое время окажется меньше старого, путь через ребро B и станет новым кратчайшим путём для этой вершины.
Этап 3: помечаем вершину B как пройденную.
Этап 4: перейти к этапу 1.
Цикл этих этапов мы будем повторять до тех пор, пока все вершины не будут пройдены.

Давайте рассмотрим следующий взвешенный направленный граф:
Итак, с помощью вышеприведенного алгоритма мы определим кратчайший путь от A до G:
Для вершины A есть три возможных пути: к B с весом 3, к С с весом 5 и к D с весом 7. Согласно первому пункту алгоритма выбираем узел с наименьшей стоимостью перехода — то есть к B.
Так как единственной непройденной вершиной-соседом для B будет вершина Е, мы проверяем, каков будет путь при прохождении через эту вершину. 3(AB) + 6(BE) = 9.
Таким образом, мы отмечаем что текущий кратчайший путь до AE = 9.

Так как наша работа с вершиной B уже закончена, переходим к выбору следующей вершины с минимальным весом ребра до неё.
С вершин A и B это могут быть вершины D(7), C(5), E(6).

Наименьший вес ребра имеет С, поэтому к этой вершине и перейдем.

Далее, как и раньше, выясняем кратчайший путь к соседним вершинам при проходе через С:
AD = 5(AC) + 3(CD) = 8, но так как предыдущий кратчайший путь AC = 7, то есть меньше, чем этот через С, мы так и оставляем кратчайший путь AC = 7, без изменений.
CE = 5(AC) + 4(CE) = 9, этот новый кратчайший путь равен прежнему поэтому мы оставляем его без изменения тоже.
Из ближайших доступных вершин, E и D, выбираем вершину с наименьшим весом ребра, то есть D(3).
Выясняем кратчайший путь до его соседа — F.
AF = 7(AD) + 3(DF) = 9

Из ближайших доступных вершин E и F, выбираем вершину с наименьшим весом ребра к ней, то есть F(3).
Выясняем кратчайший путь до его соседа — G.
AG = 7(AD) + 3(DF) + 4(FG) = 14

Собственно, вот мы и нашли путь от A до G.

Но чтобы убедиться в том, что он кратчайший, мы должны прогнать наши этапы и для вершины E.

Так как у вершины G нет соседних вершин, к которым вел бы направленный путь, у нас остаётся только вершина E: выбираем ее.
Выясняем кратчайший путь до соседа — G.
AG = 3(AB) + 6(BE) + 6(EG) = 15, этот путь длиннее прежнего кратчайшего AG(14), поэтому данный путь мы оставляем без изменений.

Так как вершин, ведущих от G, нет, прогонять этапы для данной вершины не имеет смысла. Поэтому работу алгоритма можно считать законченной.

Как я и говорил ранее, помимо выяснения кратчайшего пути для AG, мы получили кратчайшие пути до всех вершин от вершины A (AB, AC, AD, AE, AF).

Что ж, пришло время взглянуть, каким образом это возможно реализовать на Java.

Для начала рассмотрим класс вершины:

public class Vertex {
   private char label;
   private boolean isInTree;

   public Vertex(char label) {
       this.label = label;
       this.isInTree = false;
   }

   public char getLabel() {
       return label;
   }

   public void setLabel(char label) {
       this.label = label;
   }

   public boolean isInTree() {
       return isInTree;
   }

   public void setInTree(boolean inTree) {
       isInTree = inTree;
   }
}

Класс вершины фактически идентичен классу вершины из поиска в глубину и ширину.
 
Чтобы отобразить кратчайшие пути, нам понадобится новый класс, который будет содержать необходимые нам данные:

public class Path { 
// объект данного класса содержащий расстояние и предыдущие и пройденные вершины

   private int distance; 
// текущая дистанция от начальной вершины

   private List parentVertices; 
// текущий родитель вершины


   public Path(int distance) {
       this.distance = distance;
       this.parentVertices = new ArrayList<>();
   }

   public int getDistance() {
       return distance;
   }

   public void setDistance(int distance) {
       this.distance = distance;
   }

   public List getParentVertices() {
       return parentVertices;
   }

   public void setParentVertices(List parentVertices) {
       this.parentVertices = parentVertices;
   }
}

В данном классе мы можем видеть общую дистанцию пути и вершины, которые будут пройдены при проходе по найкрайчайшему пути.

А сейчас хотелось бы рассмотреть класс в котором, собственно, и происходит кратчайший обход графа.

Итак, класс графа:

public class Graph {
   private final int MAX_VERTS = 10;
// максимальное количество вершин

   private final int INFINITY = 100000000; 
// это число у нас будет служить в качестве "бесконечности"

   private Vertex vertexList[]; 
// список вершин

   private int relationMatrix[][]; 
// матрица связей вершин

   private int countOfVertices; 
// текущее количество вершин

   private int countOfVertexInTree; 
// количество рассмотренных вершин в дереве

   private List shortestPaths; 
// список данных кратчайших путей

   private int currentVertex; 
// текущая вершина

   private int startToCurrent; 
//расстояние до currentVertex


   public Graph() {
       vertexList = new Vertex[MAX_VERTS]; 
// матрица смежности

       relationMatrix = new int[MAX_VERTS][MAX_VERTS];
       countOfVertices = 0;
       countOfVertexInTree = 0;
       for (int i = 0; i < MAX_VERTS; i++) {
// матрица смежности заполняется

           for (int k = 0; k < MAX_VERTS; k++) { 
// бесконечными расстояниями

               relationMatrix[i][k] = INFINITY; 
// задания значений по умолчанию

               shortestPaths = new ArrayList<>();
// задается пустым

           }
       }
   }

   public void addVertex(char lab) {
// задание новых вершин

       vertexList[countOfVertices++] = new Vertex(lab);
   }

   public void addEdge(int start, int end, int weight) {
       relationMatrix[start][end] = weight; 
// задание ребер между вершинами, с весом между ними

   }

   public void path() { 
// выбор кратчайшего пути

       
//  задание данных для стартовой вершины

       int startTree = 0; 
// стартуем с вершины 0

       vertexList[startTree].setInTree(true); 
// включение в состав дерева первого элемента

       countOfVertexInTree = 1;

       
// заполнение коротких путей для вершин смежных с стартовой

       for (int i = 0; i < countOfVertices; i++) {
           int tempDist = relationMatrix[startTree][i];
           Path path = new Path(tempDist);
           path.getParentVertices().add(0);
// первым родительским элементом, будет всегда стартовая вершина

           shortestPaths.add(path);
       }
       
// пока все вершины не окажутся в дереве

       while (countOfVertexInTree < countOfVertices) { 
// выполняем, пока количество вершин в дереве не сравняется с общим количеством вершин

           int indexMin = getMin();
//получаем индекс вершины с наименшей дистанцией, из вершин еще не входящих в дерево

           int minDist = shortestPaths.get(indexMin).getDistance();
// минимальная дистанция вершины, из тек которые ещё не в дереве


           if (minDist == INFINITY) {
               System.out.println("В графе пристувствуют недостижимые вершины");
               break;
// в случае если остались непройденными только недостижимые вершины, мы выходим из цикла

           } else {
               currentVertex = indexMin; 
// переводим указатель currentVert к текущей вершине

               startToCurrent = shortestPaths.get(indexMin).getDistance();
// задаем дистанцию к текущей вершине

           }

           vertexList[currentVertex].setInTree(true);  
//включение текущей вершины в дерево

           countOfVertexInTree++; 
// увеличиваем счетчик вершин в дереве

           updateShortestPaths(); 
// обновление списка кратчайших путей

       }

       displayPaths(); 
// выводим в консоль результаты

   }

   public void clean() { 
// очиска дерева

       countOfVertexInTree = 0;
       for (int i = 0; i < countOfVertices; i++) {
           vertexList[i].setInTree(false);
       }
   }

   private int getMin() {
       int minDist = INFINITY; 
// за точку старта взята "бесконечная" длина

       int indexMin = 0;
       for (int i = 1; i < countOfVertices; i++) {
// для каждой вершины

           if (!vertexList[i].isInTree() && shortestPaths.get(i).getDistance() < minDist) { 
// если вершина ещё не ве дереве и её растояние меньше старого минимума

               minDist = shortestPaths.get(i).getDistance(); 
// задаётся новый минимум

               indexMin = i; 
// обновление индекса вершины содержащую минимаьную дистанцию

           }
       }
       return indexMin; 
//возвращает индекс вершины с наименшей дистанцией, из вершин еще не входящих в дерево

   }

   private void updateShortestPaths() {
       int vertexIndex = 1; 
// стартовая вершина пропускается

       while (vertexIndex < countOfVertices) { 
// перебор столбцов


           if (vertexList[vertexIndex].isInTree()) { 
// если вершина column уже включена в дерево, она пропускается

               vertexIndex++;
               continue;
           }
           
// вычисление расстояния для одного элемента sPath

           
// получение ребра от currentVert к column

           int currentToFringe = relationMatrix[currentVertex][vertexIndex];
           
// суммирование всех расстояний

           int startToFringe = startToCurrent + currentToFringe;
           
// определение расстояния текущего элемента vertexIndex

           int shortPathDistance = shortestPaths.get(vertexIndex).getDistance();

           
// сравнение расстояния через currentVertex с текущим расстоянием в вершине с индексом vertexIndex

           if (startToFringe < shortPathDistance) {
// если меньше, то у вершины под индексом vertexIndex будет задан новый кратчайший путь

               List newParents = new ArrayList<>(shortestPaths.get(currentVertex).getParentVertices());
//создаём копию списка родителей вершины currentVert

               newParents.add(currentVertex);
// задаём в него и currentVertex как предыдущий

               shortestPaths.get(vertexIndex).setParentVertices(newParents); 
// соохраняем новый маршут

               shortestPaths.get(vertexIndex).setDistance(startToFringe); 
// соохраняем новую дистанцию

           }
           vertexIndex++;
       }
   }

   private void displayPaths() { 
// метод для вывода кратчайших путей на экран

       for (int i = 0; i < countOfVertices; i++) {
           System.out.print(vertexList[i].getLabel() + " = ");
           if (shortestPaths.get(i).getDistance() == INFINITY) {
               System.out.println("0");
           } else {
               String result = shortestPaths.get(i).getDistance() + " (";
               List parents = shortestPaths.get(i).getParentVertices();
               for (int j = 0; j < parents.size(); j++) {
                   result += vertexList[parents.get(j)].getLabel() + " -> ";
               }
               System.out.println(result + vertexList[i].getLabel() + ")");
           }
       }
   }
}

Собственно, вот и вся магия =)

Ну а теперь, давайте взглянем на данный алгоритм в действии:

public class Solution {

   public static void main(String[] args) {
       Graph graph = new Graph();
       graph.addVertex('A');
       graph.addVertex('B');
       graph.addVertex('C');
       graph.addVertex('D');
       graph.addVertex('E');
       graph.addVertex('F');
       graph.addVertex('G');

       graph.addEdge(0, 1, 3);
       graph.addEdge(0, 2, 5);
       graph.addEdge(0, 3, 7);
       graph.addEdge(1, 4, 6);
       graph.addEdge(2, 4, 4);
       graph.addEdge(2, 3, 3);
       graph.addEdge(3, 5, 3);
       graph.addEdge(4, 6, 6);
       graph.addEdge(5, 6, 4);

       System.out.println("Элементы имеют кратчайшие пути из точки A: ");
       graph.path();
       graph.clean();
   }
}

И вывод в консоли:

Элементы имеют кратчайшие пути из точки A: 
A = 0
B = 3 (A -> B)
C = 5 (A -> C)
D = 7 (A -> D)
E = 9 (A -> B -> E)
F = 10 (A -> D -> F)
G = 14 (A -> D -> F -> G)

Временная сложность данного алгоритма — ничто иное как O(N²), так как у нас есть циклы, вложенные в цикл.

Что же, на этом у меня сегодня всё, спасибо за внимание!
https://javarush.ru/groups/posts/3022-chto-sprashivajut-na-sobesedovanii-obzor-algoritmov-chastjh-2


